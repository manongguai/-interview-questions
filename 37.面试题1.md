1.vuex 中 mutation 中为什么不能执行异步？

Vuex 中所有的状态更新的唯一途径都是 mutation，异步操作通过 Action 来提交 mutation 实现，这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。

每个 mutation 执行完成后都会对应到一个新的状态变更，这样 devtools 就可以打个快照存下来，然后就可以实现 time-travel 了。如果 mutation 支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。

2.Vue-Router 和 React-Router 对比
一、路由本质
前端路由本质的两种支持：(改变视图的同时不会向后端发出请求。)

hash —— 即地址栏 URL 中的 # 符号。 onhashchange 事件获取
MDN ：MDN
history —— 利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。（注意兼容性）
PS:（Apache 或 Nginx 需要配置）
MDN ：MDN

vue-router 是全局配置方式，react-router 是全局组件方式。
vue-router 仅支持对象形式的配置，react-router 支持对象形式和 JSX 语法的组件形式配置。
vue-router 任何路由组件都会被渲染到<router-view/>位置，react-router 子组件作为 children 被传入父组件，而根组件被渲染到<Router/>位置。

3.ajax 怎么中断请求 1.定义超时，
2.ajax.absort()
2.axios.cancelToken

4.js 懒加载的原理
懒加载的核心：在如何在适当的时候加载用户需要的资源(这里用户需要的资源指该资源呈现在浏览器可视区域)
例子：页面渲染时将 src 路径放到自定义属性中去，这样页面加载时图片就不会去请求服务器，当图片滚动到可视区内时，获取它的自定义属性并赋值给 src
5.promise.all 的实现

6.ts 装饰器的用法
类装饰器、属性装饰器、方法装饰器、参数装饰器

7.vue $nextTick 的原理
    this.$nextTick()将回调延迟到下次 DOM 更新循环之后执行

    Vue渲染为什么是异步更新渲染？
    如果不采取异步更新，那么每次更新数据都会对当前组件进行重新渲染，为了性能考虑，Vue 会在本轮数据更新后，再去异步更新数据

8.vue2 和 vue3 的区别

vue2 的双向数据绑定是利用 ES5 的一个 API Object.definePropert()对数据进行劫持 结合 发布订阅模式的方式来实现的。
vue3 中使用了 es6 的 ProxyAPI 对数据代理。

在 2.x 版本里，不管数据多大，都会在一开始就为其创建观察者。当数据很大时，这可能会在页面载入时造成明显的性能压力。3.x 版本，只会对「被用于渲染初始可见部分的数据」创建观察者，而且 3.x 的观察者更高效。
3.0 新加入了 TypeScript 以及 PWA 的支持

9.vue3 ref 和 reactive 的区别

10.mixins 的注意点
混入 (mixins)： 是一种分发 Vue 组件中可复用功能的非常灵活的方式。混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被混入该组件本身的选项。
如果有多个 mixins 同时实现了 created 这个钩子函数并且混入了同一个组件会报错

11.vue 中 watch 和 watchEffect 的区别
watch: 1.具有一定的惰性 lazy 第一次页面展示的时候不会执行，只有数据变化的时候才会执行

            2.参数可以拿到当前值和原始值

            3.可以侦听多个数据的变化，用一个侦听起承载

    watchEffect:
            1.立即执行，没有惰性，页面的首次加载就会执行。

            2.自动检测内部代码，代码中有依赖 便会执行

            3.不需要传递要侦听的内容 会自动感知代码依赖，不需要传递很多参数，只要传递一个回调函数

            4.不能获取之前数据的值 只能获取当前值

            5.一些=异步的操作放在这里会更加合适

12.react 的可控组件和不可控组件
在 React 中的 input 标签是有些小坑的，input 本身就有自己的缓存机制，然后 React 的 State 也有缓存机制。这两种缓存机制我们在编码中是要进行取舍的。将 input 中的 value 绑定到 state 的 React 组件就是可控组件，反之则是不可控组件

13.vue computed 和 methods 的区别

computed 可以完成各种复杂的逻辑，包括运算、函数调用等，只要最终返回一个结果就可以

用 computed 属性方法编写的逻辑运算，在调用时直接将返回时 areas 视为一个变量值就可使用，无需进行函数调用。computed 具有缓存功能，在系统刚运行的时候调用一次。只有只有当计算结果发生变化才会被调用。比如，我们在长度框与宽度框更改值的时候每次更改 computed 都会被调用一次，很浪费资源。
用 methods 方法编写的逻辑运算，在调用时 add() 一定要加“()”，methods 里面写的多位方法，调用方法一定要有（）。methods 方法页面刚加载时调用一次，以后只有被调用的时候才会被调用。我们在长度框和宽度框的值输入完以后，点击“+” methods 方法调用一次。这里很明显我们采用 methods 会更节省资源。
